<!DOCTYPE html>
<!-- saved from url=(0094)https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work -->
<html lang="en" data-reactroot=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Synchronizing CPU and GPU Work | Apple Developer Documentation</title><meta content="width=device-width, initial-scale=1 viewport-fit=cover" name="viewport"><meta data-pid="481728"><link href="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/fonts" media="all" rel="stylesheet" type="text/css"><link href="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/application-e5bb1544.css" media="all" rel="stylesheet" type="text/css"><noscript><link href="/documentation/__assets/nojs-c6be9131.css" media="all" rel="stylesheet" type="text/css"/></noscript><link rel="mask-icon" href="https://developer.apple.com/documentation/__assets/apple-logo.svg" color="#000"><link rel="shortcut icon" href="https://developer.apple.com/documentation/__assets/favicon.ico"><script src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/shared-b7676010.js"></script><script id="init-data" type="application/json">{"variant":{"paths":["documentation\/metal\/synchronization\/synchronizing_cpu_and_gpu_work","documentation\/metal\/basic_tasks_and_concepts\/synchronizing_cpu_and_gpu_work"]}}</script><script src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/init-6128d031.js"></script></head><body><div id="_omniture_top">
      <script>
        var s_account="awdappledeveloper"
      </script>
      <script src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/analytics.js"></script>
      <script>
        s.pageName= AC && AC.Tracking && AC.Tracking.pageName();
        s.channel="www.documentation.developer"

        var s_code=s.t();if(s_code)document.write(s_code)
      </script>
    </div><div id="app"><div><a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work#main" id="skip-localnav" class="showonfocus hidden">Skip Navigation</a><aside id="ac-gn-segmentbar" class="ac-gn-segmentbar" lang="en-US" dir="ltr"></aside><input type="checkbox" id="ac-gn-menustate" class="ac-gn-menustate"><nav id="ac-globalnav" class="js no-touch" role="navigation" aria-label="Global" data-hires="false" data-analytics-region="global nav" lang="en-US" dir="ltr" data-store-locale="us" data-store-api="/[storefront]/shop/bag/status" data-search-locale="en_US" data-search-api="/search-services/suggestions/">
      <div class="ac-gn-content">
        <ul class="ac-gn-header">
          <li class="ac-gn-item ac-gn-menuicon">
            <label class="ac-gn-menuicon-label" for="ac-gn-menustate" aria-hidden="true">
              <span class="ac-gn-menuicon-bread ac-gn-menuicon-bread-top">
                <span class="ac-gn-menuicon-bread-crust ac-gn-menuicon-bread-crust-top"></span>
              </span>
              <span class="ac-gn-menuicon-bread ac-gn-menuicon-bread-bottom">
                <span class="ac-gn-menuicon-bread-crust ac-gn-menuicon-bread-crust-bottom"></span>
              </span>
            </label>
            <a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work#ac-gn-menustate" role="button" class="ac-gn-menuanchor ac-gn-menuanchor-open" id="ac-gn-menuanchor-open">
              <span class="ac-gn-menuanchor-label">Global Nav Open Menu</span>
            </a>
            <a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work#" role="button" class="ac-gn-menuanchor ac-gn-menuanchor-close" id="ac-gn-menuanchor-close">
              <span class="ac-gn-menuanchor-label">Global Nav Close Menu</span>
            </a>
          </li>
          <li class="ac-gn-item ac-gn-apple">
            <a class="ac-gn-link ac-gn-link-apple-developer" href="https://developer.apple.com/" data-analytics-title="appledeveloper home" id="ac-gn-firstfocus-small">
              <span class="ac-gn-link-text">Apple Developer</span>
            </a>
          </li>
        </ul>
        <div class="ac-gn-search-placeholder-container" role="search">
          <div class="ac-gn-search ac-gn-search-small">
            <a id="ac-gn-link-search-small" class="ac-gn-link" href="https://developer.apple.com/search/" data-analytics-title="search" data-analytics-click="search" data-analytics-intrapage-link="" aria-label="Search Developer" role="button" aria-haspopup="true">
              <div class="ac-gn-search-placeholder-bar">
                <div class="ac-gn-search-placeholder-input">
                  <div class="ac-gn-search-placeholder-input-text" aria-hidden="true">
                    <div class="ac-gn-link-search ac-gn-search-placeholder-input-icon"></div>
                    <span class="ac-gn-search-placeholder">Search Developer</span>
                  </div>
                </div>
                <div class="ac-gn-searchview-close ac-gn-searchview-close-small ac-gn-search-placeholder-searchview-close">
                  <span class="ac-gn-searchview-close-cancel" aria-hidden="true">Cancel</span>
                </div>
              </div>
            </a>
          </div>
        </div>
        <ul class="ac-gn-list">
          <li class="ac-gn-item ac-gn-apple">
            <a class="ac-gn-link ac-gn-link-apple-developer" href="https://developer.apple.com/" data-analytics-title="appledeveloper home" id="ac-gn-firstfocus">
              <span class="ac-gn-link-text">Apple Developer</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-discover">
            <a class="ac-gn-link ac-gn-link-discover" href="https://developer.apple.com/discover/" data-analytics-title="discover">
              <span class="ac-gn-link-text">Discover</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-design">
            <a class="ac-gn-link ac-gn-link-design" href="https://developer.apple.com/design/" data-analytics-title="design">
              <span class="ac-gn-link-text">Design</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-develop">
            <a class="ac-gn-link ac-gn-link-develop" href="https://developer.apple.com/develop/" data-analytics-title="develop">
              <span class="ac-gn-link-text">Develop</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-distribute">
            <a class="ac-gn-link ac-gn-link-distribute" href="https://developer.apple.com/distribute/" data-analytics-title="distribute">
              <span class="ac-gn-link-text">Distribute</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-dsupport">
            <a class="ac-gn-link ac-gn-link-dsupport" href="https://developer.apple.com/support/" data-analytics-title="dsupport">
              <span class="ac-gn-link-text">Support</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-account">
            <a class="ac-gn-link ac-gn-link-account" href="https://developer.apple.com/account/" data-analytics-title="account">
              <span class="ac-gn-link-text">Account</span>
              </a>
          </li>
          <li class="ac-gn-item ac-gn-item-menu ac-gn-search" role="search">
            <a id="ac-gn-link-search" class="ac-gn-link ac-gn-link-search" href="https://developer.apple.com/search/" data-analytics-title="search" data-analytics-click="search" data-analytics-intrapage-link="" aria-label="Search Developer" role="button" aria-haspopup="true"></a>
          </li>
        </ul>
        <aside id="ac-gn-searchview" class="ac-gn-searchview" role="search" data-analytics-region="search">
          <div class="ac-gn-searchview-content">
            <div class="ac-gn-searchview-bar">
              <div class="ac-gn-searchview-bar-wrapper">
                <form id="ac-gn-searchform" class="ac-gn-searchform" action="https://developer.apple.com/search/" method="get">
                  <div class="ac-gn-searchform-wrapper">
                    <input id="ac-gn-searchform-input" class="ac-gn-searchform-input" type="text" name="q" aria-label="Search Developer" placeholder="Search Developer" autocorrect="off" autocapitalize="off" autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="true" aria-owns="quicklinks suggestions">
                    <button id="ac-gn-searchform-submit" class="ac-gn-searchform-submit" type="submit" disabled="" aria-label="Submit Search"></button>
                    <button id="ac-gn-searchform-reset" class="ac-gn-searchform-reset" type="reset" disabled="" aria-label="Clear Search">
                        <span class="ac-gn-searchform-reset-background"></span>
                      </button>
                  </div>
                </form>
                <button id="ac-gn-searchview-close-small" class="ac-gn-searchview-close ac-gn-searchview-close-small" aria-label="Cancel Search">
                    <span class="ac-gn-searchview-close-cancel" aria-hidden="true">
                      Cancel
                    </span>
                  </button>
              </div>
            </div>
            <aside id="ac-gn-searchresults" class="ac-gn-searchresults" data-string-quicklinks="Quick Links" data-string-suggestions="Suggested Searches" data-string-noresults=""></aside>
          </div>
          <button id="ac-gn-searchview-close" class="ac-gn-searchview-close" aria-label="Cancel Search">
              <span class="ac-gn-searchview-close-wrapper">
                <span class="ac-gn-searchview-close-left"></span>
                <span class="ac-gn-searchview-close-right"></span>
              </span>
            </button>
        </aside>
          </div>
    </nav><div class="ac-gn-blur"></div><div id="ac-gn-curtain" class="ac-gn-curtain"></div><div id="ac-gn-placeholder" class="ac-nav-placeholder"></div><input type="checkbox" id="localnav-menustate" class="localnav-menustate" aria-hidden="true"><div id="localnav-sticky-placeholder" class="css-sticky localnav-sticking"></div><nav id="localnav" class="localnav localnav-dark theme-dark localnav-scrim localnav-noborder css-sticky localnav-sticking" role="navigation" aria-label="API Reference" data-sticky="true"><div class="localnav-wrapper"><div class="referencenav"><div class="localnav-background"></div><div class="localnav-content"><a href="https://developer.apple.com/documentation" class="localnav-title">Documentation</a><div class="localnav-menu"><a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work#localnav-menustate" id="localnav-menustate-open" class="localnav-menucta-anchor localnav-menucta-anchor-open"><span class="localnav-menucta-anchor-label" aria-hidden="true">Open Menu</span></a><a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work#" id="localnav-menustate-close" class="localnav-menucta-anchor localnav-menucta-anchor-close"><span class="localnav-menucta-anchor-label" aria-hidden="true">Close Menu</span></a><div class="localnav-menu-tray"><ul aria-label="Breadcrumbs" class="localnav-menu-items localnav-menu-breadcrumbs"><li class="localnav-menu-item localnav-menu-breadcrumb-item"><a class="localnav-menu-link" href="https://developer.apple.com/documentation/metal">Metal</a></li><li class="localnav-menu-item localnav-menu-breadcrumb-item"><a class="localnav-menu-link" href="https://developer.apple.com/documentation/metal/synchronization">Synchronization</a></li><li class="localnav-menu-item localnav-menu-breadcrumb-item"><div class="localnav-menu-breadcrumb-current-container localnav-menu-link current"><span aria-current="page" class="localnav-menu-breadcrumb-current">Synchronizing CPU and GPU Work</span></div></li></ul><ul class="localnav-menu-items localnav-menu-settings" data-breadcrumbs-count="3"><li class="localnav-menu-setting language-container"><div class="language-toggle-container"><label for="language-toggle" class="language-toggle-label">Language:</label><select id="language-toggle" class="language-dropdown localnav-menu-link" style="width: 38px;"><option selected="" value="swift">Swift</option><option value="occ">Objective-C</option></select></div><div class="language-list-container"><span class="localnav-menu-setting-label">Language:</span><ul class="language-list"><li class="language-list-item"><span data-language="swift" aria-current="page" class="current-language">Swift</span></li><li class="language-list-item"><a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work?language=objc" class="localnav-menu-setting-link">Objective-C</a></li></ul></div></li><li class="localnav-menu-setting"><span class="localnav-menu-setting-label">API Changes:</span><span class="changes-toggle">None</span></li></ul></div><div class="localnav-actions"><div class="localnav-action localnav-action-menucta" aria-hidden="true"><label for="localnav-menustate" class="localnav-menucta"><span class="localnav-menucta-chevron"></span></label></div></div></div></div></div></div></nav><label for="localnav-menustate" id="localnav-curtain" aria-hidden="true"></label><main role="main" id="main" class="main" tabindex="0"><div class="topic-title"><span class="eyebrow">Sample Code</span><h1 class="topic-heading"><span>Synchronizing CPU and GPU Work</span></h1></div><div class="topic-container section-content row"><div class="topic-description column large-9 medium-9 small-12"><div class="topic-abstract abstract formatted-content"><div><p>Avoid stalls between CPU and GPU work by using multiple instances of a resource.</p></div></div><a href="https://docs-assets.developer.apple.com/published/a91aad71cf/SynchronizingCPUAndGPUWork.zip" download="" class="downloadsample"><span class="button" aria-label="Download sample code">Download</span></a></div><div class="topic-summary column large-3 medium-3 small-12"><div class="topic-summary-section sdks" role="complementary" aria-label="SDKs"><p class="topic-summary-section-label subsection-label">SDKs</p><ul class="topic-summary-section-list"><li class="topic-summary-section-item sdk"><span aria-label="iOS 11.0+, Available on iOS 11.0 and later" role="text" title="Available on iOS 11.0 and later">iOS 11.0+</span></li><li class="topic-summary-section-item sdk"><span aria-label="tvOS 11.0+, Available on tvOS 11.0 and later" role="text" title="Available on tvOS 11.0 and later">tvOS 11.0+</span></li><li class="topic-summary-section-item sdk"><span aria-label="macOS 10.13+, Available on macOS 10.13 and later" role="text" title="Available on macOS 10.13 and later">macOS 10.13+</span></li><li class="topic-summary-section-item sdk"><span aria-label="Xcode 10.2+, Available on Xcode 10.2 and later" role="text" title="Available on Xcode 10.2 and later">Xcode 10.2+</span></li></ul></div><div class="topic-summary-section frameworks" role="complementary" aria-label="Framework"><p class="topic-summary-section-label subsection-label">Framework</p><ul class="topic-summary-section-list"><li class="topic-summary-section-item"><span>Metal</span></li></ul></div></div><div class="topic-content column large-9 medium-9 small-12" id="topic-content"><section id="overview" class="section"><h2>Overview</h2><div class="formatted-content"><div><p>In this sample code project, you learn how to manage data dependencies and avoid processor stalls between the CPU and the GPU.</p><p>The project continuously renders triangles along a sine wave. In each frame, the sample updates the position of each triangle’s vertices and then renders a new image. These dynamic data updates create an illusion of motion, where the triangles appear to move along the sine wave.</p><p></p><figure id="3191516"><img class="centered-block" src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/060934e7-bfc3-4b29-8a1d-eec7c208d8e3.png" srcset="https://docs-assets.developer.apple.com/published/9ce93e2b68/060934e7-bfc3-4b29-8a1d-eec7c208d8e3.png 2x" alt="A screenshot of the sample code project, showing colored triangles rendered along a sine wave." width="710" height="auto"></figure><p></p><p>The sample stores the triangle vertices in a buffer that’s shared between the CPU and the GPU. The CPU writes data to the buffer and the GPU reads it.</p><aside class="aside aside-note" role="note"><p class="aside-name">Note</p><p>The Xcode project contains schemes for running the sample on macOS, iOS, and tvOS. Metal is not supported in the iOS or tvOS Simulator; to run the sample, you need an iOS device for the iOS scheme and an Apple TV for the tvOS scheme. The default scheme is macOS, which runs the sample on your Mac.</p></aside></div><h3 id="3191545">Understand the Solution to Data Dependencies and Processor Stalls</h3><div><p>Resource sharing creates a <em>data dependency</em> between the processors; the CPU must finish writing to the resource before the GPU reads it. If the GPU reads the resource before the CPU writes to it, the GPU reads undefined resource data. If the GPU reads the resource while the CPU is writing to it, the GPU reads incorrect resource data.</p><p></p><figure id="3191518"><img class="centered-block" src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/77a3d759-a808-4e69-81f1-3bb2fa24e545.png" srcset="https://docs-assets.developer.apple.com/published/d9dc44d823/77a3d759-a808-4e69-81f1-3bb2fa24e545.png 2x" alt="A diagram that shows the CPU and the GPU sequentially accessing a buffer in each frame." width="710" height="auto"></figure><p></p><p>These data dependencies create <em>processor stalls</em> between the CPU and the GPU; each processor must wait for the other to finish its work before beginning its own work.</p><p>However, because the CPU and GPU are separate processors, you can make them work simultaneously by using multiple instances of a resource. Each frame, you must provide the same arguments to your shaders, but this doesn’t mean you need to reference the same resource object. Instead, you create a pool of multiple instances of a resource and use a different one each time you render a frame. For example, as shown below, the CPU can write position data to a buffer used for frame <code class="code-voice"><span>n+1</span></code>, at the same time that the GPU reads position data from a buffer used for frame <code class="code-voice"><span>n</span></code>. By using multiple instances of a buffer, the CPU and the GPU can work continuously and avoid stalls as long as you keep rendering frames.</p><p></p><figure id="3191519"><img class="centered-block" src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/4add8abb-f845-4ae6-80c1-818cba38f4e4.png" srcset="https://docs-assets.developer.apple.com/published/9ffae9d282/4add8abb-f845-4ae6-80c1-818cba38f4e4.png 2x" alt="A diagram that shows the CPU and the GPU simultaneously accessing multiple copies of a buffer in each frame." width="710" height="auto"></figure><p></p></div><h3 id="3191546">Initialize Data with the CPU</h3><div><p>Define a custom <code class="code-voice"><span>AAPLVertex</span></code> structure that represents a vertex. Each vertex has a position and a color:</p><figure id="3191521"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-keyword">typedef</span> <span class="syntax-keyword">struct</span>
{
    vector_float2 position;
    vector_float4 color;
} AAPLVertex;
</code></pre></div></div></figure><p>Define a custom <code class="code-voice"><span>AAPLTriangle</span></code> class that provides an interface to a default triangle, which is made up of 3 vertices:</p><figure id="3191522"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>+(<span class="syntax-keyword">const</span> AAPLVertex *)vertices
{
    <span class="syntax-keyword">const</span> <span class="syntax-keyword">float</span> TriangleSize = <span class="syntax-number">64</span>;
    <span class="syntax-keyword">static</span> <span class="syntax-keyword">const</span> AAPLVertex triangleVertices[] =
    {
        <span class="syntax-comment">// Pixel Positions,                          RGBA colors.</span>
        { { <span class="syntax-number">-0.5</span>*TriangleSize, <span class="syntax-number">-0.5</span>*TriangleSize },  { <span class="syntax-number">1</span>, <span class="syntax-number">1</span>, <span class="syntax-number">1</span>, <span class="syntax-number">1</span> } },
        { {  <span class="syntax-number">0.0</span>*TriangleSize, +<span class="syntax-number">0.5</span>*TriangleSize },  { <span class="syntax-number">1</span>, <span class="syntax-number">1</span>, <span class="syntax-number">1</span>, <span class="syntax-number">1</span> } },
        { { +<span class="syntax-number">0.5</span>*TriangleSize, <span class="syntax-number">-0.5</span>*TriangleSize },  { <span class="syntax-number">1</span>, <span class="syntax-number">1</span>, <span class="syntax-number">1</span>, <span class="syntax-number">1</span> } }
    };
    <span class="syntax-keyword">return</span> triangleVertices;
}
</code></pre></div></div></figure><p>Initialize multiple triangle vertices with a position and a color, and store them in an array of triangles, <code class="code-voice"><span>_triangles</span></code>:</p><figure id="3191523"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-built_in">NSMutableArray</span> *triangles = [[<span class="syntax-built_in">NSMutableArray</span> alloc] initWithCapacity:NumTriangles];

<span class="syntax-comment">// Initialize each triangle.</span>
<span class="syntax-keyword">for</span>(<span class="syntax-built_in">NSUInteger</span> t = <span class="syntax-number">0</span>; t &lt; NumTriangles; t++)
{
    vector_float2 trianglePosition;

    <span class="syntax-comment">// Determine the starting position of the triangle in a horizontal line.</span>
    trianglePosition.x = ((-((<span class="syntax-keyword">float</span>)NumTriangles) / <span class="syntax-number">2.0</span>) + t) * horizontalSpacing;
    trianglePosition.y = <span class="syntax-number">0.0</span>;

    <span class="syntax-comment">// Create the triangle, set its properties, and add it to the array.</span>
    AAPLTriangle * triangle = [AAPLTriangle new];
    triangle.position = trianglePosition;
    triangle.color = Colors[t % NumColors];
    [triangles addObject:triangle];
}
_triangles = triangles;
</code></pre></div></div></figure></div><h3 id="3191547">Allocate Data Storage</h3><div><p>Calculate the total storage size of your triangle vertices. Your app renders 50 triangles; each triangle has 3 vertices, totaling 150 vertices, and each vertex is the size of <code class="code-voice"><span>AAPLVertex</span></code>:</p><figure id="3191525"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-keyword">const</span> <span class="syntax-built_in">NSUInteger</span> triangleVertexCount = [AAPLTriangle vertexCount];
_totalVertexCount = triangleVertexCount * _triangles.count;
<span class="syntax-keyword">const</span> <span class="syntax-built_in">NSUInteger</span> triangleVertexBufferSize = _totalVertexCount * <span class="syntax-keyword">sizeof</span>(AAPLVertex);
</code></pre></div></div></figure><p>Initialize multiple buffers to store multiple copies of your vertex data. For each buffer, allocate exactly enough memory to store 150 vertices:</p><figure id="3191526"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-keyword">for</span>(<span class="syntax-built_in">NSUInteger</span> bufferIndex = <span class="syntax-number">0</span>; bufferIndex &lt; MaxFramesInFlight; bufferIndex++)
{
    _vertexBuffers[bufferIndex] = [_device newBufferWithLength:triangleVertexBufferSize
                                                       options:<span class="syntax-built_in">MTLResourceStorageModeShared</span>];
    _vertexBuffers[bufferIndex].label = [<span class="syntax-built_in">NSString</span> stringWithFormat:<span class="syntax-string">@"Vertex Buffer #%lu"</span>, (<span class="syntax-keyword">unsigned</span> <span class="syntax-keyword">long</span>)bufferIndex];
}
</code></pre></div></div></figure><p>Upon initialization, the contents of the buffer instances in the <code class="code-voice"><span>_vertex<wbr>Buffers</span></code> array are empty.</p></div><h3 id="3191548">Update Data with the CPU</h3><div><p>In each frame, at the start of the <a class="symbol-name" href="https://developer.apple.com/documentation/metalkit/mtkviewdelegate/1535942-draw"><code><span>draw(in:)</span></code></a> render loop, use the CPU to update the contents of one buffer instance in the <code class="code-voice"><span>update<wbr>State</span></code> method:</p><figure id="3191528"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-comment">// Vertex data for the current triangles.</span>
AAPLVertex *currentTriangleVertices = _vertexBuffers[_currentBuffer].contents;

<span class="syntax-comment">// Update each triangle.</span>
<span class="syntax-keyword">for</span>(<span class="syntax-built_in">NSUInteger</span> triangle = <span class="syntax-number">0</span>; triangle &lt; NumTriangles; triangle++)
{
    vector_float2 trianglePosition = _triangles[triangle].position;

    <span class="syntax-comment">// Displace the y-position of the triangle using a sine wave.</span>
    trianglePosition.y = (sin(trianglePosition.x/waveMagnitude + _wavePosition) * waveMagnitude);

    <span class="syntax-comment">// Update the position of the triangle.</span>
    _triangles[triangle].position = trianglePosition;

    <span class="syntax-comment">// Update the vertices of the current vertex buffer with the triangle's new position.</span>
    <span class="syntax-keyword">for</span>(<span class="syntax-built_in">NSUInteger</span> vertex = <span class="syntax-number">0</span>; vertex &lt; triangleVertexCount; vertex++)
    {
        <span class="syntax-built_in">NSUInteger</span> currentVertex = vertex + (triangle * triangleVertexCount);
        currentTriangleVertices[currentVertex].position = triangleVertices[vertex].position + _triangles[triangle].position;
        currentTriangleVertices[currentVertex].color = _triangles[triangle].color;
    }
}
</code></pre></div></div></figure><p>After you update a buffer instance, you don’t access its data with the CPU for the rest of the frame.</p><aside class="aside aside-note" role="note"><p class="aside-name">Note</p><p>You must finalize all CPU writes to one buffer instance before you commit a command buffer that references it. Otherwise, the GPU may begin reading the buffer instance while the CPU is still writing to it.</p></aside></div><h3 id="3191549">Encode GPU Commands</h3><div><p>Next, you encode commands that reference the buffer instance in a render pass:</p><figure id="3191530"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>[renderEncoder setVertexBuffer:_vertexBuffers[_currentBuffer]
                        offset:<span class="syntax-number">0</span>
                       atIndex:AAPLVertexInputIndexVertices];

<span class="syntax-comment">// Set the viewport size.</span>
[renderEncoder setVertexBytes:&amp;_viewportSize
                       length:<span class="syntax-keyword">sizeof</span>(_viewportSize)
                      atIndex:AAPLVertexInputIndexViewportSize];

<span class="syntax-comment">// Draw the triangle vertices.</span>
[renderEncoder drawPrimitives:<span class="syntax-built_in">MTLPrimitiveTypeTriangle</span>
                  vertexStart:<span class="syntax-number">0</span>
                  vertexCount:_totalVertexCount];
</code></pre></div></div></figure></div><h3 id="3191550">Commit and Execute GPU Commands</h3><div><p>At the end of the render loop, call your command buffer’s <a class="symbol-name" href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443003-commit"><code><span>commit()</span></code></a> method to submit your work to the GPU:</p><figure id="3191532"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>[commandBuffer commit];
</code></pre></div></div></figure><p>The GPU begins its work and reads from the <code class="code-voice"><span>vertices</span></code> buffer in the <code class="code-voice"><span>Rasterizer<wbr>Data</span></code> vertex shader, which takes the buffer instance as an input argument:</p><figure id="3191533"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="other"><code>vertex RasterizerData
vertexShader(const uint vertexID [[ vertex_id ]],
             const device AAPLVertex *vertices [[ buffer(AAPLVertexInputIndexVertices) ]],
             constant vector_uint2 *viewportSizePointer  [[ buffer(AAPLVertexInputIndexViewportSize) ]])
</code></pre></div></div></figure></div><h3 id="3191551">Reuse Multiple Buffer Instances in Your App</h3><div><p>For each frame, perform the following steps, as described above. A full frame’s work is finished when both processors have completed their work.</p><ol><li><p>Write data to a buffer instance.</p></li><li><p>Encode commands that reference the buffer instance.</p></li><li><p>Commit a command buffer that contains the encoded commands.</p></li><li><p>Read data from the buffer instance.</p></li></ol><p>When a frame’s work is finalized, the CPU and the GPU no longer need the buffer instance used in that frame. However, discarding a used buffer instance and creating a new one for each frame is expensive and wasteful. Instead, as shown below, set up your app to cycle through a first in, first out (FIFO) queue of buffer instances, <code class="code-voice"><span>_vertex<wbr>Buffers</span></code>, that you can reuse. The maximum number of buffer instances in the queue is defined by the value of <code class="code-voice"><span>Max<wbr>Frames<wbr>In<wbr>Flight</span></code>, set to 3:</p><figure id="3191535"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-keyword">static</span> <span class="syntax-keyword">const</span> <span class="syntax-built_in">NSUInteger</span> MaxFramesInFlight = <span class="syntax-number">3</span>;
</code></pre></div></div></figure><p>In each frame, at the start of the render loop, you update the next buffer instance from the <code class="code-voice"><span>_vertex<wbr>Buffer</span></code> queue. You cycle through the queue sequentially and update only one buffer instance per frame; at the end of every third frame, you return to the start of the queue:</p><figure id="3191536"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code><span class="syntax-comment">// Iterate through the Metal buffers, and cycle back to the first when you've written to the last.</span>
_currentBuffer = (_currentBuffer + <span class="syntax-number">1</span>) % MaxFramesInFlight;

<span class="syntax-comment">// Update buffer data.</span>
[<span class="syntax-keyword">self</span> updateState];
</code></pre></div></div></figure><aside class="aside aside-note" role="note"><p class="aside-name">Note</p><p>Core Animation provides optimized displayable resources, commonly referred to as <em>drawables</em>, for you to render content and display it onscreen. Drawables are efficient yet expensive system resources, so Core Animation limits the number of drawables that you can use simultaneously in your app. The default limit is 3, but you can set it to 2 with the <a class="symbol-name" href="https://developer.apple.com/documentation/quartzcore/cametallayer/2938720-maximumdrawablecount"><code><span>maximum<wbr>Drawable<wbr>Count</span></code></a> property (2 and 3 are the only supported values). Because the maximum number of drawables is 3, this sample creates 3 buffer instances. You donʼt need to create more buffer instances than the maximum number of drawables available.</p></aside></div><h3 id="3191552">Manage the Rate of CPU and GPU Work</h3><div><p>When you have multiple instances of a buffer, you can make the CPU start work for frame <code class="code-voice"><span>n+1</span></code> with one instance, while the GPU finishes work for frame <code class="code-voice"><span>n</span></code> with another instance. This implementation improves your app’s efficiency by making the CPU and the GPU work simultaneously. However, you need to manage your app’s rate of work so you don’t exceed the number of buffer instances available.</p><p>To manage your app’s rate of work, use a semaphore to wait for full frame completions in case the CPU is working much faster than the GPU. A semaphore is a non-Metal object that you use to control access to a resource that’s shared across multiple processors (or threads). The semaphore has an associated counting value, which you decrement or increment, that indicates whether a processor has started or finished accessing a resource. In your app, a semaphore controls CPU and GPU access to buffer instances.</p><p>You initialize the semaphore with a counting value of <code class="code-voice"><span>Max<wbr>Frames<wbr>In<wbr>Flight</span></code>, to match the number of buffer instances. This value indicates that your app can simultaneously work on a maximum of 3 frames at any given time:</p><figure id="3191538"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>_inFlightSemaphore = dispatch_semaphore_create(MaxFramesInFlight);
</code></pre></div></div></figure><p>At the start of the render loop, you decrement the semaphore’s counting value by 1. This indicates that you’re ready to work on a new frame. However, if the counting value falls below 0, the semaphore makes the CPU wait until you increment the value:</p><figure id="3191539"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>dispatch_semaphore_wait(_inFlightSemaphore, DISPATCH_TIME_FOREVER);
</code></pre></div></div></figure><p>At the end of the render loop, you register a command buffer completion handler. When the GPU completes the command buffer’s execution, it calls this completion handler and you increment the semaphore’s counting value by 1. This indicates that you’ve completed all work for a given frame and you can reuse the buffer instance used in that frame:</p><figure id="3191540"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>__block dispatch_semaphore_t block_semaphore = _inFlightSemaphore;
[commandBuffer addCompletedHandler:^(<span class="syntax-keyword">id</span>&lt;<span class="syntax-built_in">MTLCommandBuffer</span>&gt; buffer)
 {
     dispatch_semaphore_signal(block_semaphore);
 }];
</code></pre></div></div></figure><p>The <a class="symbol-name" href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler"><code><span>add<wbr>Completed<wbr>Handler(_:)</span></code></a> method registers a block of code that’s called immediately after the GPU has finished executing the associated command buffer. Because you use only one command buffer per frame, receiving the completion callback indicates that the GPU has completed the frame.</p></div><h3 id="3191553">Set the Mutability of Your Buffers</h3><div><p>Your app performs all per-frame rendering setup on a single thread. First it writes data to a buffer instance with the CPU. After that, it encodes rendering commands that reference the buffer instance. Finally, it commits a command buffer for GPU execution. Because these tasks always happen in this order on a single thread, the app guarantees that it finishes writing data to a buffer instance before it encodes a command that references the buffer instance.</p><p>This order allows you to mark your buffer instances as immutable. When you configure your render pipeline descriptor, set the <a class="symbol-name" href="https://developer.apple.com/documentation/metal/mtlpipelinebufferdescriptor/2879274-mutability"><code><span>mutability</span></code></a> property of the vertex buffer at the buffer instance index to <a class="symbol-name" href="https://developer.apple.com/documentation/metal/mtlmutability/immutable"><code><span>MTLMutability<wbr>.immutable</span></code></a>:</p><figure id="3191542"><div class="formatted-content"><div class="code-listing"><pre class="code-source" data-language="occ"><code>pipelineStateDescriptor.vertexBuffers[AAPLVertexInputIndexVertices].mutability = <span class="syntax-built_in">MTLMutabilityImmutable</span>;
</code></pre></div></div></figure><p>Metal can optimize the performance of immutable buffers, but not mutable buffers. For best results, use immutable buffers as much as possible.</p></div></div></section></div></div></main><section id="globalfooter-wrapper"><footer id="globalfooter" role="contentinfo">
        <nav class="footer-breadory">
          <a href="https://developer.apple.com/" class="home breadcrumbs-home"><span aria-hidden="true"></span><span class="breadcrumbs-home-label">Developer</span></a>
          <section class="breadcrumbs">
            <ol class="breadcrumbs-list">
              <li><a href="https://developer.apple.com/documentation">Documentation</a></li>
            </ol>
          </section>
          <div id="directorynav" class="directorynav">
            <div id="dn-cola" class="column">
              <h3><a href="https://developer.apple.com/discover/">Discover</a></h3>
              <ul>
                <li><a href="https://developer.apple.com/macos/">macOS</a></li>
                <li><a href="https://developer.apple.com/ios/">iOS</a></li>
                <li><a href="https://developer.apple.com/watchos/">watchOS</a></li>
                <li><a href="https://developer.apple.com/tvos/">tvOS</a></li>
                <li><a href="https://developer.apple.com/safari/">Safari and Web</a></li>
                <li><a href="https://developer.apple.com/games/">Games</a></li>
                <li><a href="https://developer.apple.com/business/">Business</a></li>
                <li><a href="https://developer.apple.com/education/">Education</a></li>
                <li><a href="https://developer.apple.com/wwdc/">WWDC</a></li>
              </ul>
            </div>
            <div id="dn-colb" class="column">
              <h3><a href="https://developer.apple.com/design/">Design</a></h3>
              <ul>
                <li><a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a></li>
                <li><a href="https://developer.apple.com/design/resources/">Resources</a></li>
                <li><a href="https://developer.apple.com/videos/design/">Videos</a></li>
                <li><a href="https://developer.apple.com/design/awards/">Apple Design Awards</a></li>
                <li><a href="https://developer.apple.com/accessibility/">Accessibility</a></li>
                <li><a href="https://developer.apple.com/internationalization/">Internationalization</a></li>
                <li><a href="https://developer.apple.com/accessories/">Accessories</a></li>
              </ul>
            </div>
            <div id="dn-colc" class="column">
              <h3><a href="https://developer.apple.com/develop/">Develop</a></h3>
              <ul>
                <li><a href="https://developer.apple.com/xcode/">Xcode</a></li>
                <li><a href="https://developer.apple.com/swift/">Swift</a></li>
                <li><a href="https://developer.apple.com/swift-playgrounds/">Swift Playgrounds</a></li>
                <li><a href="https://developer.apple.com/testflight/">TestFlight</a></li>
                <li><a href="https://developer.apple.com/documentation/">Documentation</a></li>
                <li><a href="https://developer.apple.com/videos/">Videos</a></li>
                <li><a href="https://developer.apple.com/download/">Downloads</a></li>
              </ul>
            </div>
            <div id="dn-cold" class="column">
              <h3><a href="https://developer.apple.com/distribute/">Distribute</a></h3>
              <ul>
                <li><a href="https://developer.apple.com/programs/">Developer Program</a></li>
                <li><a href="https://developer.apple.com/app-store/">App Store</a></li>
                <li><a href="https://developer.apple.com/app-store/review/">App Review</a></li>
                <li><a href="https://developer.apple.com/macos/distribution/">Mac Software</a></li>
                <li><a href="https://developer.apple.com/business/distribute/">Apps for Business</a></li>
                <li><a href="https://developer.apple.com/safari/extensions/">Safari Extensions</a></li>
                <li><a href="https://developer.apple.com/app-store/marketing/guidelines/">Marketing Resources</a></li>
                <li><a href="https://developer.apple.com/softwarelicensing/">Trademark Licensing</a></li>
              </ul>
            </div>
            <div id="dn-cole" class="column">
              <h3><a href="https://developer.apple.com/support/">Support</a></h3>
              <ul>
                <li><a href="https://forums.developer.apple.com/">Developer Forums</a></li>
                <li><a href="https://developer.apple.com/bug-reporting/">Bug Reporting</a></li>
                <li><a href="https://developer.apple.com/terms/">License Agreements</a></li>
                <li><a href="https://developer.apple.com/system-status/">System Status</a></li>
                <li><a href="https://developer.apple.com/contact/">Contact Us</a></li>
              </ul>
              <h3><a href="https://developer.apple.com/account/">Account</a></h3>
              <ul>
                <li><a href="https://developer.apple.com/account/ios/certificate/">Certificates, IDs &amp; Profiles</a></li>
                <li><a href="https://appstoreconnect.apple.com/">App Store Connect</a></li>
              </ul>
            </div>
          </div>
        </nav>
        <div class="ac-gf-footer-legal">
          <div class="ac-gf-footer-news"> To receive the latest developer news, visit and subscribe to our <a href="https://developer.apple.com/news/">News and Updates</a>.
          </div>
          <div class="ac-gf-footer-legal-copyright">Copyright © 2020 Apple Inc. All rights reserved.</div>
          <div class="ac-gf-footer-legal-links">
            <a href="https://www.apple.com/legal/internet-services/terms/site.html" class="first">Terms of Use</a>
            <a href="https://www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
            <a href="https://developer.apple.com/bug-reporting/">Report Bugs</a>
            <a href="https://developer.apple.com/contact/submit/?subject=website-feedback">Feedback</a>
          </div>
          <div class="ac-gf-footer-language-links">
            <a href="https://developer.apple.com/cn/" class="first">简体中文</a>
            <a href="https://developer.apple.com/jp/">日本語</a>
            <a href="https://developer.apple.com/kr/">한국어</a>
          </div>
        </div>
      </footer></section></div></div><script id="bootstrap-data" type="application/json">{"id":2887020,"title":{"content":"Synchronizing CPU and GPU Work"},"abstract":"<div><p>Avoid stalls between CPU and GPU work by using multiple instances of a resource.<\/p><\/div>","availability":[{"introduced":"11.0","current":"13.5","platform":"iOS"},{"introduced":"11.0","current":"13.4","platform":"tvOS"},{"introduced":"10.13","current":"10.15.4","platform":"macOS"},{"introduced":"10.2","current":"11.5","platform":"Xcode"}],"repository":{"downloadURL":"https:\/\/docs-assets.developer.apple.com\/published\/a91aad71cf\/SynchronizingCPUAndGPUWork.zip","checksum":"77c387c53ec94da0b3874e64c15cc572a640b93b06375644a3e13a5f587ef5add7438c9c5476edcb1a9b0e5df7957f1e927a6ca9697e4162a345d695af084cf1"},"discussion":"<div><p>In this sample code project, you learn how to manage data dependencies and avoid processor stalls between the CPU and the GPU.<\/p><p>The project continuously renders triangles along a sine wave. In each frame, the sample updates the position of each triangle’s vertices and then renders a new image. These dynamic data updates create an illusion of motion, where the triangles appear to move along the sine wave.<\/p><p><figure id=\"3191516\"><img class=\"centered-block\" src=\"https:\/\/docs-assets.developer.apple.com\/published\/9ce93e2b68\/060934e7-bfc3-4b29-8a1d-eec7c208d8e3.png\" srcSet=\"https:\/\/docs-assets.developer.apple.com\/published\/9ce93e2b68\/060934e7-bfc3-4b29-8a1d-eec7c208d8e3.png 2x\" alt=\"A screenshot of the sample code project, showing colored triangles rendered along a sine wave.\" width=\"710\" height=\"auto\"\/><\/figure><\/p><p>The sample stores the triangle vertices in a buffer that’s shared between the CPU and the GPU. The CPU writes data to the buffer and the GPU reads it.<\/p><aside class=\"aside aside-note\" role=\"note\"><p class=\"aside-name\">Note<\/p><p>The Xcode project contains schemes for running the sample on macOS, iOS, and tvOS. Metal is not supported in the iOS or tvOS Simulator; to run the sample, you need an iOS device for the iOS scheme and an Apple TV for the tvOS scheme. The default scheme is macOS, which runs the sample on your Mac.<\/p><\/aside><\/div><h3 id=\"3191545\">Understand the Solution to Data Dependencies and Processor Stalls<\/h3><div><p>Resource sharing creates a <em>data dependency<\/em> between the processors; the CPU must finish writing to the resource before the GPU reads it. If the GPU reads the resource before the CPU writes to it, the GPU reads undefined resource data. If the GPU reads the resource while the CPU is writing to it, the GPU reads incorrect resource data.<\/p><p><figure id=\"3191518\"><img class=\"centered-block\" src=\"https:\/\/docs-assets.developer.apple.com\/published\/d9dc44d823\/77a3d759-a808-4e69-81f1-3bb2fa24e545.png\" srcSet=\"https:\/\/docs-assets.developer.apple.com\/published\/d9dc44d823\/77a3d759-a808-4e69-81f1-3bb2fa24e545.png 2x\" alt=\"A diagram that shows the CPU and the GPU sequentially accessing a buffer in each frame.\" width=\"710\" height=\"auto\"\/><\/figure><\/p><p>These data dependencies create <em>processor stalls<\/em> between the CPU and the GPU; each processor must wait for the other to finish its work before beginning its own work.<\/p><p>However, because the CPU and GPU are separate processors, you can make them work simultaneously by using multiple instances of a resource. Each frame, you must provide the same arguments to your shaders, but this doesn’t mean you need to reference the same resource object. Instead, you create a pool of multiple instances of a resource and use a different one each time you render a frame. For example, as shown below, the CPU can write position data to a buffer used for frame <code class=\"code-voice\"><span>n+1<\/span><\/code>, at the same time that the GPU reads position data from a buffer used for frame <code class=\"code-voice\"><span>n<\/span><\/code>. By using multiple instances of a buffer, the CPU and the GPU can work continuously and avoid stalls as long as you keep rendering frames.<\/p><p><figure id=\"3191519\"><img class=\"centered-block\" src=\"https:\/\/docs-assets.developer.apple.com\/published\/9ffae9d282\/4add8abb-f845-4ae6-80c1-818cba38f4e4.png\" srcSet=\"https:\/\/docs-assets.developer.apple.com\/published\/9ffae9d282\/4add8abb-f845-4ae6-80c1-818cba38f4e4.png 2x\" alt=\"A diagram that shows the CPU and the GPU simultaneously accessing multiple copies of a buffer in each frame.\" width=\"710\" height=\"auto\"\/><\/figure><\/p><\/div><h3 id=\"3191546\">Initialize Data with the CPU<\/h3><div><p>Define a custom <code class=\"code-voice\"><span>AAPLVertex<\/span><\/code> structure that represents a vertex. Each vertex has a position and a color:<\/p><figure id=\"3191521\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>typedef struct\n{\n    vector_float2 position;\n    vector_float4 color;\n} AAPLVertex;\n<\/code><\/pre><\/div><\/div><\/figure><p>Define a custom <code class=\"code-voice\"><span>AAPLTriangle<\/span><\/code> class that provides an interface to a default triangle, which is made up of 3 vertices:<\/p><figure id=\"3191522\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>+(const AAPLVertex *)vertices\n{\n    const float TriangleSize = 64;\n    static const AAPLVertex triangleVertices[] =\n    {\n        \/\/ Pixel Positions,                          RGBA colors.\n        { { -0.5*TriangleSize, -0.5*TriangleSize },  { 1, 1, 1, 1 } },\n        { {  0.0*TriangleSize, +0.5*TriangleSize },  { 1, 1, 1, 1 } },\n        { { +0.5*TriangleSize, -0.5*TriangleSize },  { 1, 1, 1, 1 } }\n    };\n    return triangleVertices;\n}\n<\/code><\/pre><\/div><\/div><\/figure><p>Initialize multiple triangle vertices with a position and a color, and store them in an array of triangles, <code class=\"code-voice\"><span>_triangles<\/span><\/code>:<\/p><figure id=\"3191523\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>NSMutableArray *triangles = [[NSMutableArray alloc] initWithCapacity:NumTriangles];\n\n\/\/ Initialize each triangle.\nfor(NSUInteger t = 0; t &lt; NumTriangles; t++)\n{\n    vector_float2 trianglePosition;\n\n    \/\/ Determine the starting position of the triangle in a horizontal line.\n    trianglePosition.x = ((-((float)NumTriangles) \/ 2.0) + t) * horizontalSpacing;\n    trianglePosition.y = 0.0;\n\n    \/\/ Create the triangle, set its properties, and add it to the array.\n    AAPLTriangle * triangle = [AAPLTriangle new];\n    triangle.position = trianglePosition;\n    triangle.color = Colors[t % NumColors];\n    [triangles addObject:triangle];\n}\n_triangles = triangles;\n<\/code><\/pre><\/div><\/div><\/figure><\/div><h3 id=\"3191547\">Allocate Data Storage<\/h3><div><p>Calculate the total storage size of your triangle vertices. Your app renders 50 triangles; each triangle has 3 vertices, totaling 150 vertices, and each vertex is the size of <code class=\"code-voice\"><span>AAPLVertex<\/span><\/code>:<\/p><figure id=\"3191525\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>const NSUInteger triangleVertexCount = [AAPLTriangle vertexCount];\n_totalVertexCount = triangleVertexCount * _triangles.count;\nconst NSUInteger triangleVertexBufferSize = _totalVertexCount * sizeof(AAPLVertex);\n<\/code><\/pre><\/div><\/div><\/figure><p>Initialize multiple buffers to store multiple copies of your vertex data. For each buffer, allocate exactly enough memory to store 150 vertices:<\/p><figure id=\"3191526\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>for(NSUInteger bufferIndex = 0; bufferIndex &lt; MaxFramesInFlight; bufferIndex++)\n{\n    _vertexBuffers[bufferIndex] = [_device newBufferWithLength:triangleVertexBufferSize\n                                                       options:MTLResourceStorageModeShared];\n    _vertexBuffers[bufferIndex].label = [NSString stringWithFormat:@&quot;Vertex Buffer #%lu&quot;, (unsigned long)bufferIndex];\n}\n<\/code><\/pre><\/div><\/div><\/figure><p>Upon initialization, the contents of the buffer instances in the <code class=\"code-voice\"><span>_vertex<wbr\/>Buffers<\/span><\/code> array are empty.<\/p><\/div><h3 id=\"3191548\">Update Data with the CPU<\/h3><div><p>In each frame, at the start of the <a class=\"symbol-name\" href=\"\/documentation\/metalkit\/mtkviewdelegate\/1535942-draw\"><code><span>draw(in:)<\/span><\/code><\/a> render loop, use the CPU to update the contents of one buffer instance in the <code class=\"code-voice\"><span>update<wbr\/>State<\/span><\/code> method:<\/p><figure id=\"3191528\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>\/\/ Vertex data for the current triangles.\nAAPLVertex *currentTriangleVertices = _vertexBuffers[_currentBuffer].contents;\n\n\/\/ Update each triangle.\nfor(NSUInteger triangle = 0; triangle &lt; NumTriangles; triangle++)\n{\n    vector_float2 trianglePosition = _triangles[triangle].position;\n\n    \/\/ Displace the y-position of the triangle using a sine wave.\n    trianglePosition.y = (sin(trianglePosition.x\/waveMagnitude + _wavePosition) * waveMagnitude);\n\n    \/\/ Update the position of the triangle.\n    _triangles[triangle].position = trianglePosition;\n\n    \/\/ Update the vertices of the current vertex buffer with the triangle&#x27;s new position.\n    for(NSUInteger vertex = 0; vertex &lt; triangleVertexCount; vertex++)\n    {\n        NSUInteger currentVertex = vertex + (triangle * triangleVertexCount);\n        currentTriangleVertices[currentVertex].position = triangleVertices[vertex].position + _triangles[triangle].position;\n        currentTriangleVertices[currentVertex].color = _triangles[triangle].color;\n    }\n}\n<\/code><\/pre><\/div><\/div><\/figure><p>After you update a buffer instance, you don’t access its data with the CPU for the rest of the frame.<\/p><aside class=\"aside aside-note\" role=\"note\"><p class=\"aside-name\">Note<\/p><p>You must finalize all CPU writes to one buffer instance before you commit a command buffer that references it. Otherwise, the GPU may begin reading the buffer instance while the CPU is still writing to it.<\/p><\/aside><\/div><h3 id=\"3191549\">Encode GPU Commands<\/h3><div><p>Next, you encode commands that reference the buffer instance in a render pass:<\/p><figure id=\"3191530\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>[renderEncoder setVertexBuffer:_vertexBuffers[_currentBuffer]\n                        offset:0\n                       atIndex:AAPLVertexInputIndexVertices];\n\n\/\/ Set the viewport size.\n[renderEncoder setVertexBytes:&amp;_viewportSize\n                       length:sizeof(_viewportSize)\n                      atIndex:AAPLVertexInputIndexViewportSize];\n\n\/\/ Draw the triangle vertices.\n[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle\n                  vertexStart:0\n                  vertexCount:_totalVertexCount];\n<\/code><\/pre><\/div><\/div><\/figure><\/div><h3 id=\"3191550\">Commit and Execute GPU Commands<\/h3><div><p>At the end of the render loop, call your command buffer’s <a class=\"symbol-name\" href=\"\/documentation\/metal\/mtlcommandbuffer\/1443003-commit\"><code><span>commit()<\/span><\/code><\/a> method to submit your work to the GPU:<\/p><figure id=\"3191532\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>[commandBuffer commit];\n<\/code><\/pre><\/div><\/div><\/figure><p>The GPU begins its work and reads from the <code class=\"code-voice\"><span>vertices<\/span><\/code> buffer in the <code class=\"code-voice\"><span>Rasterizer<wbr\/>Data<\/span><\/code> vertex shader, which takes the buffer instance as an input argument:<\/p><figure id=\"3191533\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"other\"><code>vertex RasterizerData\nvertexShader(const uint vertexID [[ vertex_id ]],\n             const device AAPLVertex *vertices [[ buffer(AAPLVertexInputIndexVertices) ]],\n             constant vector_uint2 *viewportSizePointer  [[ buffer(AAPLVertexInputIndexViewportSize) ]])\n<\/code><\/pre><\/div><\/div><\/figure><\/div><h3 id=\"3191551\">Reuse Multiple Buffer Instances in Your App<\/h3><div><p>For each frame, perform the following steps, as described above. A full frame’s work is finished when both processors have completed their work.<\/p><ol><li><p>Write data to a buffer instance.<\/p><\/li><li><p>Encode commands that reference the buffer instance.<\/p><\/li><li><p>Commit a command buffer that contains the encoded commands.<\/p><\/li><li><p>Read data from the buffer instance.<\/p><\/li><\/ol><p>When a frame’s work is finalized, the CPU and the GPU no longer need the buffer instance used in that frame. However, discarding a used buffer instance and creating a new one for each frame is expensive and wasteful. Instead, as shown below, set up your app to cycle through a first in, first out (FIFO) queue of buffer instances, <code class=\"code-voice\"><span>_vertex<wbr\/>Buffers<\/span><\/code>, that you can reuse. The maximum number of buffer instances in the queue is defined by the value of <code class=\"code-voice\"><span>Max<wbr\/>Frames<wbr\/>In<wbr\/>Flight<\/span><\/code>, set to 3:<\/p><figure id=\"3191535\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>static const NSUInteger MaxFramesInFlight = 3;\n<\/code><\/pre><\/div><\/div><\/figure><p>In each frame, at the start of the render loop, you update the next buffer instance from the <code class=\"code-voice\"><span>_vertex<wbr\/>Buffer<\/span><\/code> queue. You cycle through the queue sequentially and update only one buffer instance per frame; at the end of every third frame, you return to the start of the queue:<\/p><figure id=\"3191536\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>\/\/ Iterate through the Metal buffers, and cycle back to the first when you&#x27;ve written to the last.\n_currentBuffer = (_currentBuffer + 1) % MaxFramesInFlight;\n\n\/\/ Update buffer data.\n[self updateState];\n<\/code><\/pre><\/div><\/div><\/figure><aside class=\"aside aside-note\" role=\"note\"><p class=\"aside-name\">Note<\/p><p>Core Animation provides optimized displayable resources, commonly referred to as <em>drawables<\/em>, for you to render content and display it onscreen. Drawables are efficient yet expensive system resources, so Core Animation limits the number of drawables that you can use simultaneously in your app. The default limit is 3, but you can set it to 2 with the <a class=\"symbol-name\" href=\"\/documentation\/quartzcore\/cametallayer\/2938720-maximumdrawablecount\"><code><span>maximum<wbr\/>Drawable<wbr\/>Count<\/span><\/code><\/a> property (2 and 3 are the only supported values). Because the maximum number of drawables is 3, this sample creates 3 buffer instances. You donʼt need to create more buffer instances than the maximum number of drawables available.<\/p><\/aside><\/div><h3 id=\"3191552\">Manage the Rate of CPU and GPU Work<\/h3><div><p>When you have multiple instances of a buffer, you can make the CPU start work for frame <code class=\"code-voice\"><span>n+1<\/span><\/code> with one instance, while the GPU finishes work for frame <code class=\"code-voice\"><span>n<\/span><\/code> with another instance. This implementation improves your app’s efficiency by making the CPU and the GPU work simultaneously. However, you need to manage your app’s rate of work so you don’t exceed the number of buffer instances available.<\/p><p>To manage your app’s rate of work, use a semaphore to wait for full frame completions in case the CPU is working much faster than the GPU. A semaphore is a non-Metal object that you use to control access to a resource that’s shared across multiple processors (or threads). The semaphore has an associated counting value, which you decrement or increment, that indicates whether a processor has started or finished accessing a resource. In your app, a semaphore controls CPU and GPU access to buffer instances.<\/p><p>You initialize the semaphore with a counting value of <code class=\"code-voice\"><span>Max<wbr\/>Frames<wbr\/>In<wbr\/>Flight<\/span><\/code>, to match the number of buffer instances. This value indicates that your app can simultaneously work on a maximum of 3 frames at any given time:<\/p><figure id=\"3191538\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>_inFlightSemaphore = dispatch_semaphore_create(MaxFramesInFlight);\n<\/code><\/pre><\/div><\/div><\/figure><p>At the start of the render loop, you decrement the semaphore’s counting value by 1. This indicates that you’re ready to work on a new frame. However, if the counting value falls below 0, the semaphore makes the CPU wait until you increment the value:<\/p><figure id=\"3191539\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>dispatch_semaphore_wait(_inFlightSemaphore, DISPATCH_TIME_FOREVER);\n<\/code><\/pre><\/div><\/div><\/figure><p>At the end of the render loop, you register a command buffer completion handler. When the GPU completes the command buffer’s execution, it calls this completion handler and you increment the semaphore’s counting value by 1. This indicates that you’ve completed all work for a given frame and you can reuse the buffer instance used in that frame:<\/p><figure id=\"3191540\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>__block dispatch_semaphore_t block_semaphore = _inFlightSemaphore;\n[commandBuffer addCompletedHandler:^(id&lt;MTLCommandBuffer&gt; buffer)\n {\n     dispatch_semaphore_signal(block_semaphore);\n }];\n<\/code><\/pre><\/div><\/div><\/figure><p>The <a class=\"symbol-name\" href=\"\/documentation\/metal\/mtlcommandbuffer\/1442997-addcompletedhandler\"><code><span>add<wbr\/>Completed<wbr\/>Handler(_:)<\/span><\/code><\/a> method registers a block of code that’s called immediately after the GPU has finished executing the associated command buffer. Because you use only one command buffer per frame, receiving the completion callback indicates that the GPU has completed the frame.<\/p><\/div><h3 id=\"3191553\">Set the Mutability of Your Buffers<\/h3><div><p>Your app performs all per-frame rendering setup on a single thread. First it writes data to a buffer instance with the CPU. After that, it encodes rendering commands that reference the buffer instance. Finally, it commits a command buffer for GPU execution. Because these tasks always happen in this order on a single thread, the app guarantees that it finishes writing data to a buffer instance before it encodes a command that references the buffer instance.<\/p><p>This order allows you to mark your buffer instances as immutable. When you configure your render pipeline descriptor, set the <a class=\"symbol-name\" href=\"\/documentation\/metal\/mtlpipelinebufferdescriptor\/2879274-mutability\"><code><span>mutability<\/span><\/code><\/a> property of the vertex buffer at the buffer instance index to <a class=\"symbol-name\" href=\"\/documentation\/metal\/mtlmutability\/immutable\"><code><span>MTLMutability<wbr\/>.immutable<\/span><\/code><\/a>:<\/p><figure id=\"3191542\"><div class=\"formatted-content\"><div class=\"code-listing\"><pre class=\"code-source\" data-language=\"occ\"><code>pipelineStateDescriptor.vertexBuffers[AAPLVertexInputIndexVertices].mutability = MTLMutabilityImmutable;\n<\/code><\/pre><\/div><\/div><\/figure><p>Metal can optimize the performance of immutable buffers, but not mutable buffers. For best results, use immutable buffers as much as possible.<\/p><\/div>","containingGroup":[{"id":3021626,"role":"task","paths":[],"abstract":"<div><p>Use semaphores or events to coordinate actions across threads. Copy shared data to multiple buffers to avoid multi-threaded resource contention.<\/p><\/div>","symbols":[{"id":2887020,"role":"sampleCode","paths":["documentation\/metal\/synchronization\/synchronizing_cpu_and_gpu_work","documentation\/metal\/basic_tasks_and_concepts\/synchronizing_cpu_and_gpu_work"],"abstract":"<div><p>Avoid stalls between CPU and GPU work by using multiple instances of a resource.<\/p><\/div>","title":{"content":"Synchronizing CPU and GPU Work"}}],"title":{"content":"Essentials"}}],"modules":[{"title":{"content":"Metal"},"paths":["documentation\/metal"],"importStatement":"<import xml:space=\"preserve\"><keyWord>import<\/keyWord> Metal<\/import>","availability":[{"platform":"Mac Catalyst","introduced":"13.0"},{"platform":"macOS","introduced":"10.11"},{"platform":"iOS","introduced":"8.0"},{"platform":"tvOS","introduced":"9.0"}]}],"role":"sampleCode","language":"swift","roleHeading":"Sample Code","languages":["occ","swift"],"variants":{"occ":{"paths":["documentation\/metal\/synchronization\/synchronizing_cpu_and_gpu_work","documentation\/metal\/basic_tasks_and_concepts\/synchronizing_cpu_and_gpu_work"]},"swift":{"paths":["documentation\/metal\/synchronization\/synchronizing_cpu_and_gpu_work","documentation\/metal\/basic_tasks_and_concepts\/synchronizing_cpu_and_gpu_work"]}},"pid":481728,"paths":["documentation\/metal\/synchronization\/synchronizing_cpu_and_gpu_work","documentation\/metal\/basic_tasks_and_concepts\/synchronizing_cpu_and_gpu_work"],"hierarchy":[[{"id":1613708,"role":"collection","title":{"content":"Metal"},"paths":["documentation\/metal"]},{"id":3148997,"role":"collectionGroup","title":{"content":"Synchronization"},"paths":["documentation\/metal\/synchronization"]}],[{"id":1613708,"role":"collection","title":{"content":"Metal"},"paths":["documentation\/metal"]},{"id":3195013,"role":"collectionGroup","title":{"content":"Basic Tasks and Concepts"},"paths":["documentation\/metal\/basic_tasks_and_concepts"]}]],"legalNotices":{"copyright":"Copyright &copy; 2020 Apple Inc. All rights reserved.","termsOfUse":"https:\/\/www.apple.com\/legal\/internet-services\/terms\/site.html","privacyPolicy":"https:\/\/www.apple.com\/privacy\/privacy-policy"}}</script><script src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/TopicDetail-e635bc11.js"></script><script src="./Synchronizing CPU and GPU Work _ Apple Developer Documentation_files/analytics-8acae80a.js"></script><div id="ac-gn-viewport-emitter"> </div><div id="localnav-viewport-emitter"> </div></body></html>